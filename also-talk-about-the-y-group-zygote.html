<p>Y组合子要解决的问题是如何用纯正的lambda表达式实现递归
以阶乘为例，可以采用下面的代码以递归的形式表达：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div></div>
<p>要求一个自然数n的阶乘只要调用<code class="highlighter-rouge">f(n)</code>即可
上述代码包含了一个赋值语句，而纯正的lambda表达式是没有赋值语句的，那么用纯正的lambda表达式能否实现递归呢？
这就是Y组合子要解决的问题，解设我们已经得到了一个Y组合子名字叫做Y，可以定义如下lambda表达式：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div></div>

<p>然后用Y包装一下g得到g_，即：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g_</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<p>要求一个自然数n的阶乘，调用<code class="highlighter-rouge">g_(n)</code>即可
也就是说，有了Y组合子，我们只需要比较简单地、<strong>与用赋值语句差不多的方式</strong> 定义一个lambda表达式，再用Y组合子包装一下，就可以实现与赋值语句定义相同的效果</p>

<p>不难看出，我们可以用类似定义阶乘的方式定义出任何需要递归调用的表达式，方法就是在表达式最外层引入一个自由变量self来指代表达式本身，而在内部用self来代替自己以达到递归调用的效果</p>

<p>上述讨论的基本假设都是存在Y组合子，下面我们来试着求出Y组合子以证明Y组合子是存在的</p>

<p>以g为例，重点是指代g的那个self, 如何保证在调用<code class="highlighter-rouge">self(n-1)</code>的时候效果和调用<code class="highlighter-rouge">g_(n-1)</code>一样呢？</p>

<p>g本身是不能接受一个n的，必须得指定一个self，调用<code class="highlighter-rouge">g(self)</code>之后才有可能再接受一个n，于是我们猜测Y包装g的时候构造了这样一个self并且返回的是和<code class="highlighter-rouge">g(self)</code>同阶的表达式</p>

<p>同阶这个概念还是太过模糊，不妨假设<code class="highlighter-rouge">Y(g)=g(self)</code></p>

<p>再进一步，我们为了保证<code class="highlighter-rouge">self(n-1)</code>和<code class="highlighter-rouge">g_(n-1)</code>效果一样再假设<code class="highlighter-rouge">self=g_=Y(g)</code></p>

<p>这样，基于以上假设，只要<code class="highlighter-rouge">g(self)=self</code>就能保证<code class="highlighter-rouge">self(n-1)</code>的效果和<code class="highlighter-rouge">g_(n-1)</code>的效果是一样的</p>

<p>虽然假设条件过于苛刻而失去了通用性，但是只要能作为充分条件求出一个Y组合子便能证明这样的Y组合子是存在的</p>

<p>那么现在只要给出满足<code class="highlighter-rouge">g(self)=self</code>的self就可以构造出Y组合子了
于是self正是g的不动点，Y组合子又叫不动点组合子就是这么来的</p>

<p>受知识所限，我也不知道应该怎样求lambda表达式的不动点，翻阅资料得知，self应该是<code class="highlighter-rouge">gen(gen)</code>这样的形式，即<code class="highlighter-rouge">self=gen(gen)</code>，其中</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gen</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>
<p>于是<code class="highlighter-rouge">gen(gen) = g(gen(gen))</code>
（关于gen的合理性由于笔者目前知识有限，先不作讨论，待填坑）</p>

<p>这样就找到了g的不动点</p>

<p>现在我们开始构造Y组合子：
由上面的讨论可以知道<code class="highlighter-rouge">Y(g)=self=gen(gen)=g(gen(gen))</code>
则</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
</code></pre></div></div>
<p>即</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">gen</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
</code></pre></div></div>
<p>即</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
</code></pre></div></div>
<p>由此便得到了Y组合子</p>

<p>PS: 为方便理解以上lambda表达式全部都以Python语法表示，不保证一定能在Python解释器里执行</p>
